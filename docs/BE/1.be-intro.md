---
title: "Backend"
description: "Intro to Backend"
id: be-intro
---

# Understanding backend systems

## Introduction

If APIs are the menu that helps frontend and backend communicate, then the backend is the entire kitchen operation - from storing ingredients to preparing meals to managing orders. 

## What is a backend/server?

### The kitchen analogy

- **Frontend**: The dining room where customers sit, read menus, and place orders
- **API**: - **API**: The waiter who takes orders from customers (frontend) and delivers them to the kitchen (backend), then brings the prepared food back to the customer
- **Backend**: The kitchen where food is prepared, recipes are stored, and inventory is managed
- **Server**: Not the person who brings food, but the kitchen itself that processes all requests

The backend handles the data and logic behind what users see. When you search for a product, post a comment, or check your account balance, the frontend sends your request to the backend, which processes it and sends back the result.

### Server vs Backend
Server = The physical or virtual computer/machine that runs 24/7 and responds to requests  
Backend = The application code, logic, databases, and systems that run ON the server


### What servers actually do

A server is simply a computer that:
- Runs 24/7 to handle requests
- Stores and retrieves data
- Processes business logic
- Manages security and user permissions
- Coordinates with other systems

**Real-world example**: When you log into Netflix, the backend verifies your password, retrieves your watch history, recommends shows based on your preferences, and streams video content - all while the frontend simply displays the results.

## Databases and data storage

### The pantry and filing system

If the backend is the kitchen, the database is the pantry and filing cabinet combined. It's where everything is stored in an organized way so it can be found quickly.

### Types of databases

| Database type | What it stores | Restaurant analogy | Common tools |
|---------------|----------------|-------------------|--------------|
| Relational (SQL) | Structured data in tables with relationships | Recipe cards organized in categories with cross-references | PostgreSQL, MySQL, SQL Server |
| Document (NoSQL) | Flexible data in document format | A cookbook where each recipe can have different fields | MongoDB, Couchbase |
| Key-value | Simple pairs of keys and values | A spice rack where each container is labeled | Redis, DynamoDB |
| Graph | Data with complex relationships | The network of suppliers, ingredients, and dishes | Neo4j |

### When to use what

**Relational databases** work well when:
- Data has clear relationships (customers have orders, orders have items)
- You need consistency (bank transactions must be accurate)
- Structure is predictable

**Document databases** work well when:
- Data structure varies (different products have different attributes)
- You need flexibility and speed
- Relationships are simple

**Real-world example**: An e-commerce company might use PostgreSQL for order processing and user accounts (needs accuracy and relationships), Redis for shopping cart data (needs speed), and MongoDB for product catalog (needs flexibility for different product types).

## Server-side logic and processing

### The recipe execution

Server-side logic is like following a recipe with decision points:

1. **Validation**: Check if you have all ingredients (Is the email valid? Is the user old enough?)
2. **Processing**: Follow the steps (Calculate the total, apply discount codes, check inventory)
3. **Decision-making**: Handle variations (If item is out of stock, suggest alternatives)
4. **Response**: Plate and serve (Format the data and send it back to frontend)

### Common backend tasks

**Business logic examples**:
- Calculating shipping costs based on weight, distance, and delivery speed
- Determining which users see which content based on permissions
- Processing payments and handling refunds
- Generating reports from stored data
- Sending automated emails when certain events occur

**Why backend handles these tasks**:
- Security: Sensitive calculations shouldn't happen in the frontend where users can tamper with them
- Consistency: Everyone gets the same calculation
- Performance: Heavy processing doesn't slow down the user's browser
- Data access: Only backend has access to the full database

## Authentication and security

### The bouncer and security system

Authentication and security are like a restaurant's security measures:
- **Checking ID**: Verifying you are who you say you are (authentication)
- **Table assignments**: Determining what you're allowed to access (authorization)
- **Security cameras**: Logging who did what and when (audit trails)
- **Safe**: Protecting sensitive information (encryption)

### Key security concepts

| Concept | What it means | Real-world example |
|---------|---------------|-------------------|
| Authentication | Proving who you are | Logging in with username and password |
| Authorization | What you're allowed to do | Admins can delete posts, regular users cannot |
| Encryption | Scrambling data so others can't read it | Credit card numbers stored as gibberish |
| Tokens | A temporary pass after you log in | Session that lasts until you log out |
| Hashing | One-way scrambling of passwords | Storing passwords so even the company can't see them |

### Why security happens in backend

**Never trust the frontend**: Anything in the frontend can be manipulated by users. Security checks must happen where users can't interfere.

**Example of bad practice**:
- Frontend: "User clicked 'buy' button, they must have enough money"
- Backend: Should check the actual account balance

**Example of good practice**:
- Frontend: Sends purchase request
- Backend: Verifies user identity, checks actual balance, validates product availability, processes payment, then confirms

## Backend languages and frameworks

### The kitchen staff and their tools

Different programming languages and frameworks are like different cooking styles and kitchen equipment. Each has strengths for different situations.

### Popular backend technologies

| Language | Framework | Best for | Who uses it |
|----------|-----------|----------|-------------|
| JavaScript | Node.js, Express | Fast development, real-time features | Netflix, LinkedIn, Uber |
| Python | Django, Flask | Data processing, clear code | Instagram, Spotify, Dropbox |
| Java | Spring Boot | Large enterprise systems | Amazon, eBay, LinkedIn |
| C# | .NET | Microsoft environments, enterprise | Stack Overflow, GE |
| PHP | Laravel | Web applications, content sites | Facebook, WordPress, Slack |
| Ruby | Rails | Rapid development, startups | GitHub, Shopify, Airbnb |
| Go | Gin, Echo | High performance, concurrent tasks | Google, Uber, Twitch |

### What non-developers should know

You don't need to learn these languages, but understanding their characteristics helps with:

**Planning**: "We need real-time notifications" → Node.js might be good
**Hiring**: "We're a Microsoft shop" → C# developers would fit well
**Communication**: "The data processing is slow" → Might need Python optimization or different approach

## How backend connects to frontend via APIs

### The complete order flow

Let's trace a complete example: A user adds an item to their shopping cart.

**Step 1: Frontend action**
- User clicks "Add to cart" button
- Frontend prepares API request: POST /api/cart with item details

**Step 2: Backend receives request**
- Server receives the request
- Checks authentication token: "Is this user logged in?"
- Validates data: "Is this a real product? Is the quantity reasonable?"

**Step 3: Backend processes**
- Retrieves user's current cart from database
- Checks product availability
- Calculates any price changes or promotions
- Updates cart in database

**Step 4: Backend responds**
- Formats response with updated cart
- Sends back to frontend

**Step 5: Frontend updates**
- Receives confirmation
- Updates the cart icon
- Shows success message

### The API is the bridge

Remember from Session 4: The API defines how frontend and backend communicate. The backend implements what the API promises.

**API documentation says**: "POST /api/cart adds item to cart"
**Backend implements**: All the logic to actually make that happen safely and correctly

## Backend architecture patterns

### Different kitchen layouts

Just as restaurants can organize their kitchens differently, backends can be structured in different ways.

| Pattern | Description | When to use | Example |
|---------|-------------|-------------|---------|
| Monolithic | Everything in one large application | Smaller projects, simpler needs | Early-stage startup with one product |
| Microservices | Separate small services that communicate | Large scale, different teams | Netflix has separate services for recommendations, streaming, billing |
| Serverless | Code runs only when needed, no permanent server | Variable traffic, specific tasks | Image processing that happens when users upload photos |

### What this means for teams

**Monolithic**:
- One team can understand the whole system
- Easier to develop initially
- Changes can affect everything

**Microservices**:
- Teams can work independently on different services
- One service failing doesn't crash everything
- More complex to coordinate

**Communication tip**: When discussing projects, understand which pattern your company uses. It affects timelines, team structure, and how changes are made.

## Practical backend considerations

### Performance and scaling

As your application grows, the backend needs to handle more requests:

**Scaling strategies**:
- **Vertical**: Get a bigger server (upgrade the kitchen)
- **Horizontal**: Add more servers (open multiple kitchens)
- **Caching**: Store common results temporarily (keep popular dishes ready)
- **Load balancing**: Distribute requests across servers (send customers to different kitchens)

### Monitoring and maintenance

Backend systems need constant attention:
- **Logging**: Record what happens for debugging
- **Monitoring**: Track performance and errors
- **Backups**: Regularly save database contents
- **Updates**: Apply security patches and improvements

**Why this matters for non-developers**: When you report a bug or request a feature, backend work often involves these considerations. "Why does this take so long?" might be answered by "We need to migrate the database safely without losing customer data."

## Real-world backend scenarios

### Scenario 1: E-commerce checkout

**What you see**: Click "Place order" button

**What backend does**:
1. Verifies user is logged in
2. Checks all items are still in stock
3. Validates shipping address
4. Calculates tax based on location
5. Processes payment through payment provider
6. Creates order record in database
7. Reduces inventory counts
8. Sends confirmation email
9. Notifies warehouse system
10. Returns confirmation to frontend

**Why it takes time**: Each step needs to complete successfully, and payment processing must be secure.

### Scenario 2: Social media feed

**What you see**: Scroll through posts

**What backend does**:
1. Identifies who you follow
2. Retrieves recent posts from database
3. Applies filtering rules (blocked users, reported content)
4. Ranks posts by algorithm (popularity, relevance, recency)
5. Loads images from storage
6. Formats everything for frontend
7. Tracks what you viewed for future recommendations

**Why personalization matters**: Two users see different feeds from the same backend because server-side logic customizes the response.

### Scenario 3: Real-time collaboration

**What you see**: Another user's cursor moving in a shared document

**What backend does**:
1. Receives edit from User A
2. Validates change and user permissions
3. Stores change in database
4. Broadcasts to all connected users viewing that document
5. Handles conflicts if users edit same section
6. Maintains document history for undo/version control

**Technology choice**: This needs WebSocket connections (real-time) rather than standard API calls.

## Key takeaways for cross-team collaboration

### When talking with developers

**Instead of**: "Just make it faster"
**Say**: "Users report the checkout takes too long. Is this a frontend rendering issue or backend processing? What's the bottleneck?"

**Instead of**: "Why can't users just edit that?"
**Say**: "What security or data consistency issues would arise if users could edit this directly?"

**Instead of**: "This should be simple"
**Say**: "Help me understand what backend changes this requires"

### Questions to ask in planning meetings

1. What backend services will this feature need?
2. Are we creating new database tables or modifying existing ones?
3. What happens to existing data when we make this change?
4. Do we need to integrate with external systems?
5. What are the security implications?
6. How will this scale if usage grows?

### Red flags to watch for

- "We'll store passwords in plain text" → Security risk
- "We'll do all calculations in the frontend" → Users can manipulate results
- "We don't need backups" → Data loss risk
- "We'll skip authentication for now" → Security nightmare
- "One database for everything is fine" → Performance and scaling issues

## Conclusion

The backend is the foundation of any digital product. While users never see it directly, it's responsible for security, data integrity, business logic, and performance. Understanding backend systems helps you:

- Communicate more effectively with technical teams
- Make better decisions about features and priorities
- Understand why certain things take time
- Identify potential problems before they occur
- Ask the right questions in planning meetings

In our next session, we'll explore how frontend, backend, and APIs all work together in complete application architecture, including deployment and infrastructure.

## Quick reference guide

**Backend handles**:
- Data storage and retrieval
- User authentication and authorization
- Business logic and calculations
- Security and validation
- Integration with external systems
- Performance optimization

**Common backend technologies**:
- Languages: JavaScript, Python, Java, C#, PHP, Ruby, Go
- Databases: PostgreSQL, MySQL, MongoDB, Redis
- Frameworks: Express, Django, Spring Boot, .NET, Laravel, Rails

**Key concepts**:
- Server: Computer that processes requests
- Database: Organized data storage
- API implementation: Backend code that fulfills API contracts
- Authentication: Verifying identity
- Authorization: Controlling access
- Scaling: Handling increased traffic